{% load static %}
<head>
    <title>Comms Project</title>
    <link rel="stylesheet" href="{% static 'base/index.css' %}">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js" type="text/javascript"></script>
    <script src="https://unpkg.com/openpgp@5.11.2/dist/openpgp.min.js"></script>
</head>
<body>
    <audio id="remote-audio"></audio>

    <div id="voice-call">

    </div>

    <div class="new-chat-overlay" id="new-chat-overlay" style="display: none">
        <h2 style="margin: 10px 0">New chat</h2>
        <input class="search-user-input" id="search-user-input" type="search" placeholder="Search" aria-label="Search" name="search" >
        <button class="search-user-button" id="search-user-button" type="submit" hidden="hidden">Search</button>

        <div class="users">
            <ul id="users-list" class="chat-list"></ul>
            <span style="visibility: hidden">No Users!</span>
        </div>
    </div>

    <div class="new-chat-overlay" id="new-group-overlay" style="display: none">
        <h2 style="margin: 10px 0">New group</h2>
        <input class="search-user-input" id="new-group-search-user-input" type="search" placeholder="Search" aria-label="Search" name="search" >
        <button class="search-user-button" id="new-group-search-user-button" type="submit" hidden="hidden">Search</button>

        <div class="group-users">
            <ul id="group-users-list" class="chat-list" style="border-bottom-color: white"></ul>
            <span style="visibility: hidden">No Users!</span>
        </div>

        <div style="width: 100%; height: 2px; background-color: white"></div>
        <div class="selected-users">
            <ul id="selected-users-list" class="chat-list"></ul>
            <span style="visibility: hidden">No Users!</span>
        </div>

        <div style="display: flex; gap: 3px; position: absolute; bottom: 10px; left: 2.5%; width: 95%;">
            <input class="search-user-input" id="group-name-input" style="margin: 0" type="text" placeholder="Group name" aria-label="Group name" name="name" >
            <button class="send-button" id="create-group-button" type="submit">Create</button>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div id="logout-button"><img src="{% static 'base/logout.png' %}" class="sidebar-icon" alt="Logout"></div>
            <form action="{% url 'base:logout' %}" method="post" id="logout-form">
                {% csrf_token %}
            </form>
        </div>

        <div class="chat-list-container">
            <div class="chat-list-header">
                <h2 style="float: left; margin-left: 5px">Chats</h2>

                <div class="chat-list-header-button" id="new-chat-button"><img src="{% static 'base/new_chat.png' %}" class="chat-list-header-icon" id="new-chat-icon" alt="Create new chat"></div>
                <div class="chat-list-header-button" id="new-group-button"><img src="{% static 'base/new-group.png' %}" class="chat-list-header-icon" id="new-group-icon" alt="Create new group"></div>
            </div>

            <ul class="chat-list" id="chat-list">
                {% if chats.count > 0 %}
                    {% for chat in chats %}
                        <li chat-id="{{ chat.id }}" class="chat"{% if chat.name != None %} group="true" {% endif %}style="text-wrap: wrap">
                            <span>{% if chat.name == None %}{% for user in chat.users.all %}{% if user.username != request.user.username %}{{user.username}}{% endif %}{% endfor %}{% else %}{{chat.name}}{% endif %}</span>
                            <span chat-id="{{ chat.id }}" class="chat-notification" style="display: none">0</span>
                            <span class="chat-element-date"></span>
                            <div class="chat-element-preview">
                                {% if chat.messages.last != None %}
                                    <span message-id="{{ chat.messages.last.id }}"></span><span message-id="{{ chat.messages.last.id }}"></span>
                                {% else %}
                                    <span></span><span></span>
                                {% endif %}
                            </div>
                        </li>
                    {% endfor %}
                {% else %}
                    <li id="no-chats-banner">No chats are available.</li>
                {% endif %}
            </ul>
        </div>

        <div class="chat-container" style="background-image: url({% static 'base/background-default.png' %})">
            <div class="chat-header" id="chat-header">
                <span id="chat-header-username"></span>
                <div id="online-icon"></div>
                <div id="call-button" class="emoji-picker-button">
                    <img src="{% static 'base/telephone-call.png' %}" class="sidebar-icon" alt="Voice Call">
                </div>
            </div>
            <div class="chat-messages" id="chat-messages"></div>

            <div class="chat-input" id="chat-input">
                {% csrf_token %}
                <emoji-picker style="display: none" id="emoji-picker"></emoji-picker>
                <div class="emoji-picker-button" style="display: block" id="emoji-picker-button" disabled="true">
                    <img src="{% static 'base/emoji-icon.png' %}" alt="Select emoji" id="emoji-icon" class="sidebar-icon">
                </div>
                <div class="emoji-picker-button" style="display: block" id="attachment-button" disabled="true">
                    <img src="{% static 'base/attachment.png' %}" alt="Attach file" id="attachment-icon" class="sidebar-icon">
                </div>

                <form id="file-form" method="POST" enctype="multipart/form-data" hidden="hidden">
                    <input type="file" id="file-input" hidden="hidden">
                </form>

                <label for="message-input"></label>
                <input type="text" id="message-input" placeholder="Type your message here..." disabled>
                <button class="send-button" id="send-button" disabled>Send</button>
            </div>
        </div>
    </div>

    <div class="go-bottom-button" id="go-bottom-button">
        <span id="go-bottom-notification">0</span>
        <img src="{% static 'base/go-bottom.png' %}" alt="Go down" id="go-bottom-icon" class="sidebar-icon">
    </div>

    <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
    <script>
        //makes the ajax django auth compatible by appending the django csrf token to ajax headers
        $.ajaxSetup({
        beforeSend: function(xhr, settings) {
             if (!(/^http:.*/.test(settings.url) || /^https:.*/.test(settings.url))) {
                 xhr.setRequestHeader("X-CSRFToken", getCookie('csrftoken'));
             }
         }, async: true,
        });

        function sha512(str) {
          return crypto.subtle.digest("SHA-512", new TextEncoder("utf-8").encode(str)).then(buf => {
            return Array.prototype.map.call(new Uint8Array(buf), x=>(('00'+x.toString(32)).slice(-2))).join('');
          });
        }

        //encrypts the private key.
        //first, it creates a derivation key from the user password, username and server-side generated salt by PBKDF2.
        //then using this key, it creates AES-GCM compatible encryption key by using PBKDF2 again.
        async function encryptPrivateKey(plaintext) {
            let enc = new TextEncoder();
            let iv = new Uint8Array(16);

            const key_material = await window.crypto.subtle.importKey("raw", enc.encode("{{ request.user.username }}" + sessionStorage.getItem("password") + "{{ pass_phrase }}"), "PBKDF2", false, ["deriveKey", "deriveBits"]);
            const enc_key = await window.crypto.subtle.deriveKey({name: "PBKDF2", salt: enc.encode("{{ pass_phrase }}"), iterations: 100000, hash: "SHA-256"}, key_material, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);

            let encoded = enc.encode(plaintext);

            return await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, enc_key, encoded).then(x => sessionStorage.setItem("enc_private_key", _arrayBufferToBase64(x)));
        }

        async function decryptPrivateKey(ciphertext) {
            let enc = new TextEncoder();
            let dec = new TextDecoder();
            let iv = new Uint8Array(16);

            const key_material = await window.crypto.subtle.importKey("raw", enc.encode("{{ request.user.username }}" + sessionStorage.getItem("password") + "{{ pass_phrase }}"), "PBKDF2", false, ["deriveKey", "deriveBits"]);
            const enc_key = await window.crypto.subtle.deriveKey({name: "PBKDF2", salt: enc.encode("{{ pass_phrase }}"), iterations: 100000, hash: "SHA-256"}, key_material, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);

            await window.crypto.subtle.decrypt({ name: "AES-GCM", iv }, enc_key, _base64ToArrayBuffer(ciphertext)).then(x => sessionStorage.setItem("private_key", dec.decode(x)));
        }

        function _arrayBufferToBase64( buffer ) {
            let binary = '';
            let bytes = new Uint8Array( buffer );
            let len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode( bytes[ i ] );
            }
            return window.btoa( binary );
        }

        function _base64ToArrayBuffer(base64) {
            let binaryString = atob(base64);
            let bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        {% if enc_private_key == None or enc_private_key == "" %} //if this is the first login of the user, create the key pair
            (async () => {
            let { privateKey, publicKey } = await openpgp.generateKey({
                type: 'ecc',
                curve: 'curve25519',
                userIDs: [{ name: "{{ form.username.value|default_if_none:'' }}", email: "{{ form.email.value|default_if_none:'' }}" }],
                passphrase: {% if pass_phrase != None %} '{{ pass_phrase }}' {% else %} "" {% endif %},
                format: 'armored'
            });

            sessionStorage.setItem("private_key", privateKey);
            userPublicKey = publicKey;

            let enc = new TextEncoder();
            const key_material = await window.crypto.subtle.importKey("raw", enc.encode("{{ request.user.username }}" + sessionStorage.getItem("password") + "{{ pass_phrase }}"), "PBKDF2", false, ["deriveKey", "deriveBits"]);
            const enc_key = await window.crypto.subtle.deriveKey({name: "PBKDF2", salt: enc.encode("{{ pass_phrase }}"), iterations: 100000, hash: "SHA-256"}, key_material, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);

            sessionStorage.setItem("enc_key", enc_key.toString());
            sessionStorage.removeItem("password");

            await encryptPrivateKey(sessionStorage.getItem("private_key")).then(x => $.ajax({
                type: "POST",
                url: "{% url 'base:set_credentials' %}",
                data: {
                    "public_key": sessionStorage.getItem("public_key"),
                    "enc_private_key": sessionStorage.getItem("enc_private_key"),
                },
                dataType: "json",
                success: function (data) {
                },
            }))
            })();
        {% else %} //decrypt the encrypted private key served by the server
            //(async () => {
            //await decryptPrivateKey("{{ enc_private_key }}").then(async x => privateKey = await openpgp.decryptKey({
            //    privateKey: await openpgp.readPrivateKey({armoredKey: sessionStorage.getItem("private_key")}),
            //    passphrase: "{{ pass_phrase }}"
            //}))
            //})();
            // decryptPrivateKey("{{ enc_private_key }}");
        {% endif %}

        function getCookie(name) {
             let cookieValue = null;

             if (document.cookie && document.cookie !== '') {
                 let cookies = document.cookie.split(';');
                 for (let i = 0; i < cookies.length; i++) {
                     let cookie = jQuery.trim(cookies[i]);

                     if (cookie.substring(0, name.length + 1) === (name + '=')) {
                         cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                         break;
                     }
                 }
             }
             return cookieValue;
        }

        const chatInput = document.getElementById("chat-input");
        const messageInput = document.getElementById("message-input");
        const fileInput = document.getElementById("file-input");
        const fileForm = document.getElementById("file-form");
        const sendButton = document.getElementById("send-button");
        const newChatButton = document.getElementById("new-chat-button");
        const newChatOverlay = document.getElementById("new-chat-overlay");
        const newGroupButton = document.getElementById("new-group-button");
        const newGroupOverlay = document.getElementById("new-group-overlay");
        const chatMessages = document.getElementById('chat-messages');
        const goBottomButton = document.getElementById("go-bottom-button");
        const goBottomNotification = document.getElementById("go-bottom-notification");
        const emojiPickerButton = document.getElementById("emoji-picker-button");
        const emojiPicker = document.querySelector("emoji-picker");
        const attachmentButton = document.getElementById("attachment-button");
        const chatHeader = document.getElementById('chat-header');
        const chatHeaderUsername = document.getElementById('chat-header-username');
        const chatHeaderOnline = document.getElementById('online-icon');
        const callButton = document.getElementById("call-button");
        const voiceCallOverlay = document.getElementById("voice-call");
        const createGroupButton = document.getElementById("create-group-button");
        let voiceCall;
        let localStream;
        let voiceCallChatId;
        let inCall = false;
        const chatSockets = {};
        let userSockets = {}
        let isUserOnline = {};
        userSockets['{{ request.user.username }}'] = createUserSocket("{{ request.user.username }}")
        const userSocket = userSockets['{{ request.user.username }}']
        let notification;
        let allMessages = {};
        let ongoingMessages = [];
        let chatUsers = {}
        let publicKeys = {}
        let userPublicKey = `{{ public_key }}`;
        let userPrivateKey;

        (async () => {
            await (async () => {
                let enc = new TextEncoder();
                const key_material = await window.crypto.subtle.importKey("raw", enc.encode("{{ request.user.username }}" + sessionStorage.getItem("password") + "{{ pass_phrase }}"), "PBKDF2", false, ["deriveKey", "deriveBits"]);
                const enc_key = await window.crypto.subtle.deriveKey({name: "PBKDF2", salt: enc.encode("{{ pass_phrase }}"), iterations: 100000, hash: "SHA-256"}, key_material, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
                sessionStorage.removeItem("password");
                await decryptPrivateKey("{{ enc_private_key }}")

                userPrivateKey = await openpgp.decryptKey({
                    privateKey: await openpgp.readPrivateKey({ armoredKey: sessionStorage.getItem("private_key") }),
                    passphrase: "{{ pass_phrase }}"
                });
            })();
        {% for chat in chats %}
            createChatSocket({{chat.id}});

            {% for user in chat.users.all %}
                {% if user.username != request.user.username %}
                    publicKeys['{{ user.username }}'] = `{{ user.public_key }}`
                    userSockets['{{user.username}}'] = createUserSocket('{{user.username}}')
                    if (!chatUsers['{{ chat.id }}']) {
                        chatUsers['{{ chat.id }}'] = [];
                    }
                    chatUsers['{{ chat.id }}'].push('{{ user.username }}')
                {% endif %}
            {% endfor %}

            {% for message in chat.messages.all %}
                {
                if (!({{ message.chat_id }} in allMessages)) {
                         allMessages[{{ message.chat_id }}] = [];
                }

                let { data: decrypted } = await openpgp.decrypt({
                    message: await openpgp.readMessage({armoredMessage: `{{ message.message }}` }),
                    decryptionKeys: userPrivateKey
                });
                allMessages[{{ message.chat_id }}].push({'message_id': {{ message.id }}, 'source_username': "{{ message.source.username }}", 'message': decrypted, 'date': '{{ message.date|date:"D, d M Y H:i:s" }}', 'chat_id': {{ message.chat_id }}, 'has_sent': {{ message.has_sent|yesno:"true,false" }}, 'file_name': '{{ message.file_name }}'});

                {% autoescape off %}
                let messageStatuses = "{{ message.statuses.all.values }}"
                messageStatuses = messageStatuses.split("[")[1].split("]")[0];

                messageStatuses = "[" + messageStatuses + "]"
                messageStatuses = messageStatuses.replaceAll("'", '"');
                messageStatuses = messageStatuses.replaceAll("True", 'true');
                messageStatuses = messageStatuses.replaceAll("False", 'false');
                let statuses = JSON.parse(messageStatuses);

                allMessages[{{ message.chat_id }}][allMessages[{{ message.chat_id }}].length - 1]["statuses"] = {};
                for (let status in statuses) {
                    allMessages[{{ message.chat_id }}][allMessages[{{ message.chat_id }}].length - 1]["statuses"][statuses[status].user_id] = statuses[status];
                }
                {% endautoescape %}

                {% if message.id == chat.messages.last.id %}
                    let chatElement = document.querySelector(".chat[chat-id='{{ chat.id }}']");
                    chatElement.children[3].children[1].textContent = allMessages[{{ chat.id }}][allMessages[{{ chat.id }}].length - 1]["message"];

                    let date = new Date(allMessages[{{ chat.id }}][allMessages[{{ chat.id }}].length - 1]["date"] + " UTC");
                    let text = getDateElement(date).textContent;
                    if (text === "Today") {
                        chatElement.children[2].textContent = date.toLocaleTimeString('en-GB', { hour: "numeric", minute: "numeric"});
                    } else {
                        chatElement.children[2].textContent = text;
                    }

                    {% if chat.messages.last.source.id == request.user.id %}
                        {% with status=chat.messages.last.statuses.values|dictsortreversed:"has_reached"|last %}
                            {% if status.has_read != False %}
                                chatElement.children[3].children[0].classList.add("blue");
                            {% endif %}
                            {% if status.has_reached != False %}
                                chatElement.children[3].children[0].textContent = "✓✓ ";
                            {% elif chat.messages.last.has_sent %}
                                chatElement.children[3].children[0].textContent = "✓";
                            {% endif %}
                            {% if chat.messages.last.file_name == None %}
                                chatElement.children[3].children[1].textContent = allMessages[{{ chat.id }}][allMessages[{{ chat.id }}].length - 1]["message"];
                            {% else %}
                                chatElement.children[3].children[1].textContent = "{{ chat.messages.last.file_name }}";
                            {% endif %}
                        {% endwith %}
                    {% else %}
                        {% if chat.name == None %}
                            {% if chat.messages.last.file_name == None %}
                                chatElement.children[3].children[1].textContent = allMessages[{{ chat.id }}][allMessages[{{ chat.id }}].length - 1]["message"];
                            {% else %}
                                chatElement.children[3].children[1].textContent = "{{ chat.messages.last.file_name }}";
                            {% endif %}
                        {% else %}
                                chatElement.children[3].children[1].textContent = "{{ chat.messages.last.source.username }}: ";
                            {% if chat.messages.last.file_name == None %}
                                chatElement.children[3].children[1].textContent += allMessages[{{ chat.id }}][allMessages[{{ chat.id }}].length - 1]["message"];
                            {% else %}
                                chatElement.children[3].children[1].textContent += "{{ chat.messages.last.file_name }}"
                            {% endif %}
                        {% endif %}
                    {% endif %}
                {% endif %}

                {% if message.source.username != request.user.username %}
                    {% for status in message.statuses.all %}
                        {% if status.user.id == request.user.id %}
                            {% if status.has_reached == False %}
                                sendMessage(chatSockets[{{ message.chat_id }}], "message_reached", {{ message.id }});
                            {% endif %}

                            {% if status.has_read == False %}
                                notification = document.querySelector(".chat-notification[chat-id='{{ message.chat_id }}']");
                                if (notification.style.display === "none") {
                                    notification.style.display = "";
                                    notification.textContent = "0";
                                }
                                notification.textContent = parseInt(notification.textContent) + 1 + "";
                            {% endif %}
                        {% endif %}
                    {% endfor %}
                {% endif %}
                }
            {% endfor %}
        {% endfor %}


        })();

        function createUserSocket(username) {
            const userSocket = new WebSocket(
                `ws://${window.location.host}/base/user/${username}/`
            );

            userSocket.onopen = function() {
                isOnline(this);
            }

            userSocket.onmessage = function(e) {
                const data = JSON.parse(e["data"]);

                if ("{{ request.user.username }}" !== data["source_username"] && (data["type"] === "chat_creation" || data["type"] === "group_creation")) {
                    const chat_id = JSON.parse(e['data'])['chat_id'];
                    const username = JSON.parse(e["data"])["source_username"];
                    const newChat = document.querySelector(".chat[chat-id='undefined']");

                    if (newChat == null || newChat.firstElementChild.textContent !==  username) {
                        const chatList = document.getElementById("chat-list");
                        const chatElement = getChatElement(chat_id, username)
                        chatElement.removeAttribute("new");

                        if (data["type"] === "group_creation") {
                            chatElement.setAttribute("group", "true");
                            chatElement.firstElementChild.textContent = data["name"];
                        }

                        chatList.insertBefore(chatElement, chatList.firstElementChild);

                        const noChatsBanner = document.querySelector("#no-chats-banner");
                        if (noChatsBanner) {
                            noChatsBanner.remove();
                        }
                    } else if (newChat.firstElementChild.textContent ===  username) { //if the tab of the source user is opened
                        newChat.setAttribute("chat-id", chat_id);
                        newChat.removeAttribute("new");

                        const notification = document.querySelector(".chat-notification[chat-id='undefined']");
                        notification.setAttribute("chat-id", chat_id);
                    }
                    createChatSocket(chat_id);

                    if(data["type"] === "chat_creation") {
                        sendChatCreationAckMessage(this, chat_id, '{{ request.user.username }}', chatSockets[chat_id]);
                    }

                    allMessages[chat_id] = [];
                } else if ("{{ request.user.username }}" !== data["source_username"] && data["type"] === "chat_creation_ack") {
                    for (let i = 0; i < ongoingMessages.length; i++) {
                        if (parseInt(ongoingMessages[i]["chat_id"]) === data["chat_id"]) {
                            sendMessage(chatSockets[ongoingMessages[i]["chat_id"]], 'chat_message', ongoingMessages[i]["source_username"], ongoingMessages[i]["message"]);
                            ongoingMessages[i]["chat_id"] = "sent";
                        }
                    }
                }
                else if (data["type"] === "is_online") {
                    isUserOnline[username] = data["value"];

                    const activeChat = document.querySelector('.chat-list li.active');

                    if (activeChat != null) {
                        const talkTo = activeChat.firstElementChild.textContent.trim();

                        if (talkTo === username) {
                            if (isUserOnline[talkTo]) {
                                chatHeaderOnline.style.display = "block";
                            } else {
                                chatHeaderOnline.style.display = "none";
                            }
                        }
                    }
                } else if (data["type"] === "public_key" && publicKeys["username"] === null) {
                    publicKeys["username"] = data["value"];
                }
            }

            userSocket.onclose = function(e) {
                console.error(e);
            };

            return userSocket;
        }

        function createChatSocket(chat_id) {
            const chatSocket = new WebSocket(
                `ws://${window.location.host}/base/chat/${chat_id}/`
            );
            chatSocket.chat_id = chat_id;

            chatSocket.onmessage = function(e) {
                const data = JSON.parse(e["data"]);
                const activeChat = document.querySelector('.chat-list li.active');
                const chat_notification = document.querySelector('.chat-notification[chat-id="' + data["chat_id"] + '"]');
                const preview = document.querySelector(".chat-list li[chat-id='"+ chat_id +"'] .chat-element-preview");
                const targetChat = document.querySelector(".chat-list li[chat-id='"+ chat_id +"']");

                if(data.type === 'chat_message' || data.type === 'chat_file') {
                    (async () => {
                    let statuses = data["statuses"];
                    let dict = {};

                    for(let status in statuses) {
                        dict[statuses[status].user_id] = statuses[status];
                    }
                    data.statuses = dict;


                    const viewingOlderMessages = chatMessages.scrollTop + chatMessages.clientHeight + 30 < chatMessages.scrollHeight;
                    if (!(data["chat_id"] in allMessages)) {
                        allMessages[data["chat_id"]] = [];
                    }

                    if (data.type === 'chat_message' || data.type === 'chat_file') {
                        const message = await openpgp.readMessage({
                            armoredMessage: data["message"]
                        });

                        const { data: decrypted } = await openpgp.decrypt({
                            message: message,
                            decryptionKeys: userPrivateKey,
                        });
                        data["message"] = decrypted;
                    }

                    allMessages[data["chat_id"]].push(data);

                    //if the incoming message's chat is open, show the message
                    if(activeChat != null && parseInt(activeChat.getAttribute("chat-id")) === parseInt(data["chat_id"])) {
                        //if this message is the first message of the day, create a "Today" indicator.
                        const todayIndicator = document.querySelector(".messageDate[today='true']");
                        if (todayIndicator == null) {
                            const date = new Date();

                            const dateElement = getDateElement(date);

                            chatMessages.appendChild(dateElement);
                        }

                        //when user responds someone, remove the "Unread Messages" indicator.
                        const unreadMessagesIndicator = document.getElementById("unread-messages");
                        if(unreadMessagesIndicator != null && data["source_username"] === "{{ request.user.username }}") {
                            unreadMessagesIndicator.remove();
                        }

                        if (activeChat.hasAttribute("group")) {
                            chatMessages.appendChild(getMessageElement(data, 0, true));
                        } else {
                            chatMessages.appendChild(getMessageElement(data, 0));
                        }

                        let date = new Date(data["date"] + " UTC");
                        targetChat.children[2].textContent = date.toLocaleTimeString('en-GB', { hour: "numeric", minute: "numeric"});

                        if (viewingOlderMessages && data["source_username"] !== "{{ request.user.username }}") {
                            goBottomNotification.textContent = parseInt(goBottomNotification.textContent) + 1 + "";
                            if(goBottomNotification.style.display === "none") {
                                goBottomNotification.style.display = "block";
                            }

                            if (chat_notification.style.display === "none") {
                                chat_notification.style.display = "";
                                chat_notification.textContent = "0";
                            }
                            chat_notification.textContent = parseInt(chat_notification.textContent) + 1 + "";
                        } else {
                            chatMessages.scrollTo(0, chatMessages.scrollHeight);
                        }

                        //if there is no scrollbar, trigger the event manually for reading the messages
                        if(chatMessages.scrollHeight === chatMessages.clientHeight) {
                            chatMessages.dispatchEvent(new CustomEvent("scroll"));
                        }
                    } else { //if incoming message's chat is not open, just increase the notification
                        if (chat_notification.style.display === "none") {
                            chat_notification.style.display = "";
                            chat_notification.textContent = "0";
                        }
                        chat_notification.textContent = parseInt(chat_notification.textContent) + 1 + "";
                    }

                    preview.children[0].classList.remove("blue");
                    preview.children[0].textContent = "";
                    preview.children[0].setAttribute("message-id", data.message_id);
                    preview.children[1].textContent = "";
                    preview.children[1].setAttribute("message-id", data.message_id);
                    preview.children[0].removeAttribute("sent");
                    preview.children[0].removeAttribute("received");
                    preview.children[1].removeAttribute("sent");
                    preview.children[1].removeAttribute("received");

                    //if this user is the receiving end, notify the sender that message is reached
                    if(data["source_username"] !== "{{ request.user.username }}") {
                        sendMessage(this, "message_reached", data.message_id);
                        if (targetChat.hasAttribute("group")) {
                            if (data.type === 'chat_file') {
                                preview.children[1].textContent = data.source_username + ":\xa0" + data.file_name;
                            } else {
                                preview.children[1].textContent = data.source_username + ":\xa0" + data.message;
                            }
                        } else {
                            if (data.type === 'chat_file') {
                                preview.children[1].textContent = data.file_name;
                            } else {
                                preview.children[1].textContent = data.message;
                            }
                        }
                        preview.children[0].setAttribute("received", "true");
                        preview.children[1].setAttribute("received", "true");
                    } else {
                        preview.children[0].textContent = "✓\xa0";
                        if (data.type === 'chat_file') {
                            preview.children[1].textContent = data.file_name;
                        } else {
                            preview.children[1].textContent = data.message;
                        }
                        preview.children[0].setAttribute("sent", "true");
                        preview.children[1].setAttribute("sent", "true");
                    }

                    let chatElement = preview.parentElement;
                    let chatList = preview.parentElement.parentElement;
                    preview.parentElement.remove();
                    chatList.insertBefore(chatElement, chatList.firstElementChild);
                    })();
                } else if (data.type === "message_reached") {
                    const messageStatus = document.querySelector(".sent[message-id='" + data.message_id + "'] span span");
                    const preview = document.querySelector(".chat-element-preview span[message-id='" + data.message_id + "']");

                    reachedMessage(chat_id, data.message_id, data.user_id);
                    if(allReached(getMessage(chat_id, data.message_id))) {
                        if(messageStatus) {
                            messageStatus.textContent = " ";
                            messageStatus.textContent += "✓✓";
                        }
                        if(preview && preview.hasAttribute("sent")) {
                            preview.textContent = "✓✓\xa0";
                        }
                    }
                }
                else if (data.type === "message_read") {
                    const messageStatus = document.querySelector(".sent[message-id='" + data.message_id + "'] span span");
                    const preview = document.querySelector(".chat-element-preview span[message-id='" + data.message_id + "']");

                    readMessage(chat_id, data.message_id, data.user_id);
                    if (allRead(getMessage(chat_id, data.message_id))) {
                        if(messageStatus) { messageStatus.classList.add("blue"); }

                        if(preview && preview.hasAttribute("sent")) { preview.classList.add("blue"); }
                    }
                }
                else if (data.type === "call_request" || data.type === "call_ack") {
                    if (data.type === "call_request" && data.source_username !== "{{ request.user.username }}") {
                        if (inCall) {

                        } else {
                            beep();
                            voiceCallOverlay.style.display = "block";
                            voiceCallOverlay.innerHTML = "";
                            let text = document.createElement("span");
                            text.textContent = "Voice call from " + data.source_username;
                            let acceptButton = document.createElement("button");
                            let declineButton = document.createElement("button");
                            let buttons = document.createElement("div");
                            acceptButton.classList.add("send-button", "voice-call-button");
                            declineButton.classList.add("send-button", "voice-call-button");
                            acceptButton.textContent = "Accept";
                            declineButton.textContent = "Decline";
                            voiceCallOverlay.appendChild(text);
                            buttons.appendChild(acceptButton);
                            buttons.appendChild(declineButton);
                            voiceCallOverlay.appendChild(buttons);

                            acceptButton.addEventListener("click", function (x) {
                                voiceCall = new RTCPeerConnection();
                                inCall = true;
                                voiceCallChatId = chat_id;

                                setVoiceCallOverlay(data.source_username, chat_id);

                                (async () => {
                                    await localStreamToRtc();
                                    await voiceCall.setRemoteDescription(data["message"]).then(() => voiceCall.createAnswer()).then((answer) => voiceCall.setLocalDescription(answer));

                                    voiceCall.ontrack = handleTrackEvent;
                                    voiceCall.onicecandidate = handleICECandidateEvent;

                                    let stream = new MediaStream();
                                    stream.addTrack(voiceCall.getReceivers()[0].track);

                                    document.getElementById("remote-audio").srcObject = stream;
                                    document.getElementById("remote-audio").autoplay = true;

                                    await sendMessage(chatSocket, "call_ack", "{{ request.user.username }}", voiceCall.localDescription);
                                })();
                            })
                            declineButton.addEventListener("click", function(x) {
                                sendMessage(chatSocket, "call_hangup");
                                voiceCallOverlay.style.display = "none";
                                inCall = false;
                            })
                        }
                    } else if (data.source_username !== "{{ request.user.username }}") {
                        inCall = true;
                        voiceCallChatId = chat_id;
                        (async () => {
                        await voiceCall.setRemoteDescription(data["message"]);

                        let stream = new MediaStream();
                        stream.addTrack(voiceCall.getReceivers()[0].track);

                        document.getElementById("remote-audio").srcObject = stream;
                        document.getElementById("remote-audio").autoplay = true;

                        voiceCallOverlay.style.display = "block";

                        setVoiceCallOverlay(data.source_username, chat_id);
                        })();
                    }
                } else if (data.type === "new_ice_candidate") {
                    if (inCall && voiceCall.remoteDescription !== null) {
                        voiceCall.addIceCandidate(data["message"]);
                    }
                } else if (data.type === "call_hangup") {
                    if (voiceCall) {
                        voiceCall.close();
                        voiceCallOverlay.style.display = "none";
                        voiceCallOverlay.innerHTML = "";
                    }
                }
            };

            chatSocket.onclose = function(e) {
                console.error(e);
            };

            chatSockets[chat_id] = chatSocket;
        }

        function runTimer(timer) {
            var x = setInterval(function() {
                if(inCall) {
                    let seconds = parseInt(timer.textContent.split(":")[1]);
                    let minutes = parseInt(timer.textContent.split(":")[0]);

                    seconds += 1;
                    if(seconds === 60) {
                        seconds -= 60;
                        minutes += 1;
                    }
                    timer.textContent = (minutes < 10? '0' + minutes : minutes) + ":" + (seconds < 10? '0' + seconds : seconds);
                }
            }, 1000);
        }

        function setVoiceCallOverlay(username, chat_id) {
            voiceCallOverlay.innerHTML = "";

            let text = document.createElement("span");
            text.textContent = username;
            let timer = document.createElement("span");
            timer.style.display = "block";
            timer.textContent = "00:00";

            runTimer(timer);

            let hangupButton = document.createElement("div");
            let hangupIcon = document.createElement("img");
            hangupIcon.classList.add("sidebar-icon");
            hangupButton.classList.add("emoji-picker-button");
            hangupButton.style.padding = "0.3 vw";
            hangupButton.style.margin = "auto";
            hangupIcon.src = "{% static 'base/hang-up.png' %}"
            voiceCallOverlay.appendChild(text);
            voiceCallOverlay.appendChild(timer);
            hangupButton.appendChild(hangupIcon);
            voiceCallOverlay.appendChild(hangupButton);

            hangupButton.addEventListener("click", function(x) {
                sendMessage(chatSockets[chat_id], "call_hangup");
                voiceCallOverlay.style.display = "none";
                inCall = false;
            })
        }

        function sendMessage(socket, type, identification, plaintext, fileName) {
            waitForSocketConnection(socket, function() {
                if(type === 'chat_message') {
                    (async () => {
                        let publicKeysArmored = [userPublicKey];
                        for (let i=0; i<chatUsers[socket.chat_id].length; i++) {
                            publicKeysArmored.push(publicKeys[chatUsers[socket.chat_id][i]]);
                        }
                        const messageKeys = await Promise.all(publicKeysArmored.map(armoredKey => openpgp.readKey({ armoredKey })));
                        const encrypted = await openpgp.encrypt({
                            message: await openpgp.createMessage({ text: plaintext }), // input as Message object
                            encryptionKeys: messageKeys,
                        });

                        socket.send(JSON.stringify({
                            'message': encrypted,
                            'source_username': identification,
                            'type': type,
                        }));
                    })();
                } else if (type === 'chat_file') {
                    socket.send(JSON.stringify({
                        'message': plaintext,
                        'source_username': identification,
                        'type': type,
                        'file_name': fileName,
                    }))
                } else if (type === 'call_request' || type === 'call_ack' || type === 'new_ice_candidate') {
                    socket.send(JSON.stringify({
                        'source_username': identification,
                        'type': type,
                        'message': plaintext,
                    }));
                } else if (type === "call_hangup") {
                    socket.send(JSON.stringify({
                        'type': type,
                    }));
                } else {
                    socket.send(JSON.stringify({
                        'message_id': identification,
                        'user_id': {{ request.user.id }},
                        'type': type,
                    }));
                }
            });
        }

        function sendChatCreationMessage(socket, chat_id, source) {
            waitForSocketConnection(socket, function() {
                socket.send(JSON.stringify({
                'chat_id': chat_id,
                'source_username': source,
                'type': "chat_creation"
                }));
            });
        }

        function sendChatCreationAckMessage(socket, chat_id, source, chat_socket) {
            waitForSocketConnection(chat_socket, function() {
                socket.send(JSON.stringify({
                'chat_id': chat_id,
                'source_username': source,
                'type': "chat_creation_ack"
                }));
            });
        }

        function isOnline(socket) {
            waitForSocketConnection(socket, function() {
                socket.send(JSON.stringify({
                'type': "is_online"
                }));
            });
        }

        function waitForSocketConnection(socket, callback) {
            setTimeout(
                function() {
                    if(socket.readyState === 1) {
                        if(callback !== undefined) {
                            callback();
                        }
                    } else {
                        waitForSocketConnection(socket, callback);
                    }
                }, 5)
        }

        async function waitForChannelConnection(dc, callback) {
            setTimeout(
                function() {
                    if(dc.readyState === "open") {
                        if(callback !== undefined) {
                            callback();
                        }
                    } else {
                        waitForSocketConnection(dc, callback);
                    }
                }, 5)
        }

        function getDateElement(date) {
            const now = new Date();
            const weekBefore = new Date();
            weekBefore.setDate(weekBefore.getDate() - 6)
            weekBefore.setHours(0,0,0);
            const dateElement = document.createElement("div");
            dateElement.classList.add("messageDate");

            if(date.valueOf() > weekBefore.valueOf()) {
                const daysOfTheWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
                const weekDayIndex = date.getDay();
                let dayOfTheWeek = daysOfTheWeek[weekDayIndex];

                if (now.getDay() === weekDayIndex) {
                    dayOfTheWeek = "Today";
                    dateElement.setAttribute("today", "true");
                }
                else if (weekDayIndex === 6 && now.getDay() === 0 || weekDayIndex === now.getDay() - 1) {
                    dayOfTheWeek = "Yesterday";
                }

                dateElement.textContent = dayOfTheWeek;
            } else {
                dateElement.textContent = date.toLocaleString().substring(0,11);
            }

            return dateElement;
        }

        function allRead(message) {
            for (let key in message['statuses']) {
              if (message["statuses"][key]["has_read"] === false) {
                  return false;
              }
            }
            return true;
        }

        function allReached(message) {
            for (let key in message['statuses']) {
              if (message["statuses"][key]["has_reached"] === false) {
                  return false;
              }
            }
            return true;
        }

        function getMessageElement(message, paging, isGroup) {
            const messageElement = document.createElement('div');
            const messageText = document.createElement('p');
            const messageTime = document.createElement('span');
            const hasRead = allRead(message);
            const hasReached = allReached(message);

            messageElement.classList.add('message', message["source_username"] === "{{ request.user.username }}" ? 'sent' : 'received');

            if ('{{ request.user.username }}' === message["source_username"]) {
                messageElement.setAttribute('has_read', hasRead + '');
                messageElement.setAttribute('has_reached', hasReached + '');
                messageElement.setAttribute('has_sent', message["has_sent"]);
            } else {
                messageElement.setAttribute('has_read', message["statuses"][{{ request.user.id }}]["has_read"] + '');
                messageElement.setAttribute('has_reached', message["statuses"][{{ request.user.id }}]["has_reached"] + '');
                messageElement.setAttribute('has_sent', message["has_sent"]);
            }

            messageText.classList.add('messageText');

            if (isGroup && message.source_username !== "{{ request.user.username }}") {
                const username = document.createElement("div");
                username.textContent = message.source_username;

                let stringUniqueHash = [...message.source_username].reduce((acc, char) => { //message username unique color
                    return char.charCodeAt(0) + ((acc << 5) - acc);
                }, 0);
                username.style.color = `hsl(${stringUniqueHash % 360}, 95%, 35%)`;

                messageElement.appendChild(username);
            }

            let content;
            let extension;
            if (message.file_name !== "None" && message.file_name) {
                let re = /(?:\.([^.]+))?$/;
                extension = re.exec(message.file_name)[1];

                switch (extension) {
                  case 'png':
                  case 'gif':
                  case 'jpg':
                  case 'jpeg':
                  case 'tif':
                  case 'bmp':
                    case 'tiff':
                        content = document.createElement("img");
                        content.src = message.message;
                        messageElement.classList.add("image");
                        break;
                    default:
                        content = document.createElement("a");
                        content.href = message.message;
                        content.textContent = message.file_name;
                        content.download = message.file_name;
                }
                messageText.appendChild(content);
            }
            else if (message.message.length > 1200) {
                messageText.textContent = message.message.substring(0, (paging + 1) * 1200);
                if (message.message.length > (paging + 1) * 1200) {
                    let readMore = document.createElement('p');
                    readMore.classList.add("read-more");
                    readMore.textContent = "Read more";
                    readMore.setAttribute("message-id", message.message_id);
                    messageText.appendChild(readMore);

                    readMore.addEventListener('click', function() {
                        let messageElement = document.querySelector(`.message[message-id="${message.message_id}"]`);
                        let oldChild = messageElement.firstElementChild;
                        let scrollHeight = chatMessages.scrollTop;
                        messageElement.insertBefore(getMessageElement(message, paging + 1, isGroup).firstElementChild, oldChild);
                        messageElement.removeChild(oldChild);
                        chatMessages.scrollTop = scrollHeight;
                        if (goBottomButton.style.display === "none") {
                            goBottomButton.style.display = "block";
                        }
                    })
                }
            } else {
                    messageText.textContent = message.message;
            }

            messageTime.classList.add('messageTime');

            const date = new Date(message.date + " UTC");
            messageTime.textContent = date.toLocaleTimeString('en-GB', { hour: "numeric", minute: "numeric"});

            messageElement.appendChild(messageText);

            if (message.message_id != null) {
                messageElement.setAttribute("message-id", message.message_id);
            } else {
                messageElement.setAttribute("message-id", message.id);
            }

            if (message["source_username"] === "{{ request.user.username }}") {
                const messageStatus = document.createElement('span');
                messageStatus.classList.add("message-status");
                messageStatus.textContent = " ";

                if (message["has_sent"] === true) {
                    messageStatus.textContent += "✓";
                }
                if (hasReached === true) {
                    messageStatus.textContent += "✓";
                }
                if (hasRead === true) {
                    messageStatus.classList.add("blue");
                }
                messageTime.appendChild(messageStatus);
            }

            messageElement.appendChild(messageTime);
            return messageElement;
        }

        function loadChat(chatId) {
            const chatMessages = document.getElementById('chat-messages');
            const activeChat = document.querySelector('.chat-list li.active');
            chatMessages.innerHTML = '';
            let messageElement;
            let dateElement;

            if (chatId !== "undefined") { //If chat is not newly created
                let messages = allMessages[chatId];

                if(messages && messages.length > 0) {
                    let flag = true;
                    let unread = false;
                    let currentDateIndicator = new Date(messages[0].date);

                    //group creation indicator needs to know group creation date
                    /* let chatElement = document.querySelector(".chat[chat-id='" + chatId + "']");
                    if (chatElement.hasAttribute("group")) {
                        let groupCreationIndicator = document.createElement("div");
                        groupCreationIndicator.classList.add("messageDate");
                        groupCreationIndicator.textContent = "Group created";
                        chatMessages.appendChild(groupCreationIndicator);
                    } */

                    for (let i = 0; i < messages.length; i++) {
                        const date = new Date(messages[i].date + " UTC");

                        if (currentDateIndicator.getDay() !== date.getDay() || currentDateIndicator.getMonth() !== date.getMonth() || currentDateIndicator.getFullYear() !== date.getFullYear()) {
                            flag = true;
                        }
                        if (flag) {
                            dateElement = getDateElement(date);
                            chatMessages.appendChild(dateElement);

                            flag = false;
                            currentDateIndicator = date;
                        }
                        currentDateIndicator = date;

                        if(messages[i]["source_username"] !== "{{ request.user.username }}" && messages[i]["statuses"][{{ request.user.id }}]["has_read"] === false && !unread) {
                            unread = true;

                            const unreadElement = document.createElement("div");
                            unreadElement.id = "unread-messages";
                            unreadElement.textContent = "↓ Unread Messages ↓";

                            chatMessages.appendChild(unreadElement);
                        }

                        if (activeChat.hasAttribute("group")) {
                            messageElement = getMessageElement(messages[i], 0, true);
                        } else {
                            messageElement = getMessageElement(messages[i], 0);
                        }

                        chatMessages.appendChild(messageElement);
                    }

                    const firstUnread = document.querySelector('.message.received[has_read="false"]');

                    if(firstUnread != null) {
                        chatMessages.scrollTo({top: firstUnread.offsetTop - chatMessages.clientHeight / 2, behavior: "instant"});
                        goBottomButton.style.display = "block";
                        goBottomNotification.style.display = "block";
                        goBottomNotification.textContent = document.querySelector('.chat-list li.active .chat-notification').textContent;
                    } else {
                        chatMessages.scrollTo(0, chatMessages.scrollHeight);
                    }

                    chatMessages.dispatchEvent(new CustomEvent("scroll"));
                }
            }

            const talkTo = document.querySelector('.chat-list li.active').firstElementChild.textContent.trim();

            chatHeaderUsername.textContent = talkTo;

            if (!activeChat.hasAttribute("group")) {
                callButton.style.display = "";
                if (isUserOnline[talkTo]) {
                    chatHeaderOnline.style.display = "block";
                } else {
                    chatHeaderOnline.style.display = "none";
                }
            } else {
                chatHeaderOnline.style.display = "none";
                callButton.style.display = "none";
            }
            chatHeader.style.display = "flex";
        }

        function clearChat() {
            chatMessages.innerHTML = '';
            chatHeaderUsername.textContent = '';
            chatHeader.style.display = "none";
            messageInput.value = '';
        }

        function readMessage(chat_id, message_id, user_id) {
            message_id = parseInt(message_id);
            user_id = parseInt(user_id);

            for (let i = 0; i < allMessages[chat_id].length; i++) {
                if (allMessages[chat_id][i]["message_id"] === message_id) {
                    allMessages[chat_id][i]["statuses"][user_id].has_read = true;
                    break;
                }
            }
        }

        function reachedMessage(chat_id, message_id, user_id) {
            message_id = parseInt(message_id);
            user_id = parseInt(user_id);

            for (let i = 0; i < allMessages[chat_id].length; i++) {
                if (allMessages[chat_id][i]["message_id"] === message_id) {
                    allMessages[chat_id][i]["statuses"][user_id].has_reached = true;
                    break;
                }
            }
        }

        function getMessage(chat_id, message_id) {
            message_id = parseInt(message_id);
            for (let i = 0; i < allMessages[chat_id].length; i++) {
                if (allMessages[chat_id][i]["message_id"] === message_id) {
                    return allMessages[chat_id][i];
                }
            }
            return null;
        }

        document.getElementById('chat-list').addEventListener('click', function(event) {
            let target = event.target;

            if(event.target.id !== "no-chats-banner" && $(event.target).parent().id !== "no-chats-banner") {
                if(event.target.parentNode.tagName.toLowerCase() === "li") {
                    target = event.target.parentNode;
                } else if (event.target.parentNode.tagName.toLowerCase() === "div"){
                    target = event.target.parentNode.parentNode;
                }

                if(target.tagName.toLowerCase() === "li") {
                    const activeChat = document.querySelector('.chat-list li.active');

                    if(emojiPicker.style.display !== "none") {
                        emojiPicker.style.display = "none";
                        emojiPickerButton.classList.remove("active");
                    }

                    clearChat();
                    if (target.classList.contains("active")) {
                        activeChat.classList.remove('active');

                        if(activeChat.getAttribute("new") !== null) {
                            activeChat.remove();

                            if(document.querySelectorAll('.chat').length === 0) {
                                document.querySelector("#no-chats-banner").style.display = "block";
                            }
                        }

                        disableMessageInput()

                        if(goBottomButton.style.display === "block") {
                            goBottomButton.style.display = "none";
                            goBottomNotification.textContent = "0";
                        }
                    }
                    else {
                        enableMessageInput()

                        if(activeChat) {
                            activeChat.classList.remove("active");
                            if(activeChat.getAttribute("new") !== null) {
                                activeChat.remove();
                            }
                        }
                        target.classList.add("active");

                        loadChat(target.getAttribute('chat-id'));
                    }
                }
            }
        })

        document.getElementById('chat-messages').addEventListener('scroll', function(event) {
            const messages = document.querySelectorAll(".message.received[has_read='false']");
            const notification = document.querySelector(".chat.active .chat-notification");
            const activeChat = document.querySelector('.chat-list li.active');

            if (activeChat !== null) {
                const activeChatId = activeChat.getAttribute('chat-id');

                messages.forEach(message => {
                    if (message.offsetTop - event.target.offsetTop < event.target.scrollTop + event.target.clientHeight - message.scrollHeight) {
                        if (message.classList.contains("received")) {
                            notification.textContent = parseInt(notification.textContent) - 1 + "";
                            message.setAttribute("has_read", 'true');
                            sendMessage(chatSockets[activeChatId], "message_read", message.getAttribute('message-id'));

                            if (goBottomNotification.textContent > 0) {
                                goBottomNotification.textContent = parseInt(goBottomNotification.textContent) - 1 + "";
                            }

                            if(parseInt(notification.textContent) === 0) {
                                notification.style.display = "none";
                            }

                            readMessage(activeChatId, message.getAttribute("message-id"), {{ request.user.id }});
                        }
                    }
                });

                if (chatMessages.scrollTop + chatMessages.clientHeight + 30 < chatMessages.scrollHeight) {
                    if (goBottomButton.style.display === "none") {
                        goBottomButton.style.display = "block";


                        if (parseInt(goBottomNotification.textContent) > 0) {
                            goBottomNotification.style.display = "block";
                        }
                    }
                } else if (goBottomButton.style.display !== "none") {
                    goBottomButton.style.display = "none";
                    goBottomNotification.style.display = "none";
                    goBottomNotification.textContent = 0 + "";
                }
            }
        });

        document.getElementById('send-button').addEventListener('click', function() {
            const messageText = messageInput.value.trim();
            const activeChat = document.querySelector('.chat-list li.active');
            let activeChatId = activeChat.getAttribute('chat-id');
            const notificationElement = document.querySelector('.chat-list li.active .chat-notification')

            if (messageText !== '') {
                if(activeChat.hasAttribute("new")) { //Creating the chat in the database when the creator sending a message
                    let users = []
                    users.push(activeChat.firstElementChild.textContent.trim());
                    $.ajax({
                    type: "POST",
                    url: "{% url 'base:create_chat' %}",
                    data: {
                        "users": users,
                    },
                    dataType: "json",
                    success: function (data) {
                        activeChat.removeAttribute("new");
                        activeChat.setAttribute("chat-id", data["chat_id"]);

                        notificationElement.setAttribute("chat-id", data["chat_id"]);
                        activeChatId = activeChat.getAttribute('chat-id');

                        chatUsers[data["chat_id"]] = users;
                        createChatSocket(data["chat_id"]);
                        allMessages[data["chat_id"]] = [];


                        if (isUserOnline[activeChat.firstElementChild.textContent]) {
                            sendChatCreationMessage(userSockets[activeChat.firstElementChild.textContent], data["chat_id"], "{{ request.user.username }}");
                            ongoingMessages.push({chat_id: activeChatId, source_username: "{{ request.user.username }}", message: messageText});
                        }
                        else {
                            sendMessage(chatSockets[activeChatId], "chat_message", "{{ request.user.username }}", messageText);
                        }

                        messageInput.value = '';
                        messageInput.focus();
                    },
                    });
                } else {
                    sendMessage(chatSockets[activeChatId], 'chat_message', "{{ request.user.username }}", messageText);

                    messageInput.value = '';
                    messageInput.focus();
                }
            }
        });

        document.getElementById('message-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('send-button').click();
            }
        });

        document.getElementById('message-input').addEventListener('click', function() {
            if(emojiPicker.style.display !== "none") {
                emojiPicker.style.display = "none";
                emojiPickerButton.classList.remove("active");
            }
        })

        function getChatElement(chat_id, username) {
            const chatElement = document.createElement('li');
            chatElement.setAttribute("chat-id", chat_id);
            chatElement.setAttribute("new", "true");
            chatElement.style.textWrap = "wrap";
            chatElement.classList.add("chat");

            const usernameElement = document.createElement("span");
            usernameElement.textContent = username;

            const notificationElement = document.createElement("span");
            notificationElement.setAttribute("chat-id", chat_id);
            notificationElement.style.display = "none";
            notificationElement.textContent = "0";
            notificationElement.classList.add("chat-notification");

            const dateElement = document.createElement("span");
            dateElement.style.display = "none";

            chatElement.appendChild(usernameElement);
            chatElement.appendChild(notificationElement);
            chatElement.appendChild(dateElement);

            const chatPreview = document.createElement("div");
            const status = document.createElement("span");
            const message = document.createElement("span");
            chatPreview.classList.add("chat-element-preview");
            chatPreview.appendChild(status);
            chatPreview.appendChild(message);
            chatElement.appendChild(chatPreview);

            return chatElement;
        }

        function enableMessageInput() {
            chatInput.style.display = "flex";

            messageInput.removeAttribute("disabled");
            sendButton.removeAttribute("disabled");
            emojiPickerButton.removeAttribute("disabled");
            attachmentButton.removeAttribute("disabled");
        }

        function disableMessageInput() {
            chatInput.style.display = "none";

            messageInput.setAttribute("disabled", "true");
            sendButton.setAttribute("disabled", "true");
            emojiPickerButton.setAttribute("disabled", "true");
            attachmentButton.setAttribute("disabled", "true");
        }

        document.getElementById('search-user-button').addEventListener('click', function() {
            const input = document.getElementById('search-user-input');

            if(input.value !== '') {
                $.ajax({
                    type: "GET",
                    url: "{% url 'base:search_user' %}",
                    data: {
                        "username": input.value,
                    },
                    dataType: "json",
                    success: function (data) {
                        const users = data["users"];
                        const userList = document.getElementById('users-list');
                        const noUsersText = document.querySelector(".users > span");

                        userList.innerHTML = '';

                        if(users.length === 0){
                            noUsersText.style.visibility = "visible";
                        } else {
                            noUsersText.style.visibility = "hidden";

                            for(let i=0; i<users.length; i++) {
                                const userElement = document.createElement('li');
                                userElement.classList.add('chat', "username");
                                userList.appendChild(userElement);

                                const userName = document.createElement('span');
                                userName.textContent = users[i].username;
                                userElement.appendChild(userName);
                            }
                        }

                        //open the chat of the user or create new
                        document.querySelectorAll('.username').forEach(el => el.addEventListener('click', () => {
                            const username = el.firstElementChild.textContent;
                            const chats = document.querySelectorAll('#chat-list .chat');
                            let alreadyChatting = false;

                            if(chats.length === 0) {
                                document.querySelector("#no-chats-banner").style.display = "none";
                            }

                            chats.forEach(chat => {
                                if (username.trim() === chat.firstElementChild.textContent.trim()) { //open the chat if it exists
                                    alreadyChatting = true;
                                    chat.click();
                                    userList.innerHTML = '';
                                    newChatOverlay.style.display = "none";

                                    const button = document.getElementById("new-chat-button");
                                    button.classList.remove("active");
                                    userList.innerHTML = '';
                                    input.value = '';
                                }
                            })
                            if (!alreadyChatting) { //create new chat
                                const chatList = document.getElementById("chat-list");
                                const button = document.getElementById("new-chat-button");

                                button.classList.remove("active");
                                newChatOverlay.style.display = "none";
                                input.value = '';

                                const activeChat = document.querySelector('#chat-list li.active');
                                if (activeChat) {
                                    activeChat.classList.remove('active');
                                }

                                const chatElement = getChatElement(data["chat_id"], username.trim());
                                chatList.appendChild(chatElement);

                                chatElement.click()

                                userSockets[chatElement.firstElementChild.textContent] = createUserSocket(chatElement.firstElementChild.textContent);

                                userList.innerHTML = '';

                                if (!(chatElement.firstElementChild.textContent in publicKeys)) {
                                    $.ajax({
                                    type: "GET",
                                    url: "{% url 'base:get_public_key' %}",
                                    data: {
                                        "username": chatElement.firstElementChild.textContent,
                                    },
                                    dataType: "json",
                                    success: function (data) {
                                        publicKeys[chatElement.firstElementChild.textContent] = data["public_key"];
                                    },
                                    })
                                }


                            }
                        }));
                    },
                    failure: function () {

                    }
                });
            }
        });

        document.getElementById('new-group-search-user-button').addEventListener('click', function() {
            const input = document.getElementById('new-group-search-user-input');

            if(input.value !== '') {
                $.ajax({
                    type: "GET",
                    url: "{% url 'base:search_user' %}",
                    data: {
                        "username": input.value,
                    },
                    dataType: "json",
                    success: function (data) {
                        const users = data["users"];
                        const userList = document.getElementById('group-users-list');
                        const noUsersText = document.querySelector(".group-users > span");

                        userList.innerHTML = '';

                        if(users.length === 0){
                            noUsersText.style.visibility = "visible";
                        } else {
                            noUsersText.style.visibility = "hidden";

                            for(let i=0; i<users.length; i++) {
                                const userElement = document.createElement('li');
                                userElement.classList.add('chat');
                                userList.appendChild(userElement);

                                const userName = document.createElement('span');
                                userName.textContent = users[i].username;
                                userName.classList.add("username")
                                userElement.appendChild(userName);
                            }
                        }

                        const selectedUsers = document.getElementById("selected-users-list")
                        document.querySelectorAll('#group-users-list .chat').forEach(el => el.addEventListener('click', () => {
                            let hasSelected = false;

                            for (let i=0; i<selectedUsers.childElementCount; i++) {
                                if (selectedUsers.children[i].firstElementChild.textContent === el.textContent) {
                                    hasSelected = true;
                                }
                            }
                            if (!hasSelected) {
                                const userElement = document.createElement("li");
                                userElement.classList.add("chat");

                                if (!(el.textContent in userSockets)) {
                                    userSockets[el.textContent] = createUserSocket(el.textContent);
                                    $.ajax({
                                    type: "GET",
                                    url: "{% url 'base:get_public_key' %}",
                                    data: {
                                        "username": el.textContent,
                                    },
                                    dataType: "json",
                                    success: function (data) {
                                        publicKeys[el.textContent] = data["public_key"];
                                    },
                                    })
                                }

                                selectedUsers.appendChild(userElement);
                                const userName = document.createElement('a');
                                userName.textContent = el.textContent;
                                userName.classList.add("username")
                                userElement.appendChild(userName);

                                userElement.addEventListener('click', function() {
                                    userElement.remove();
                                    userSockets[el.textContent].close();

                                    if(selectedUsers.childElementCount === 0) {
                                        createGroupButton.setAttribute("disabled", "disabled");
                                    }
                                })
                                el.remove();

                                if(selectedUsers.childElementCount > 0) {
                                    createGroupButton.removeAttribute("disabled");
                                }
                            }
                        }));
                    },
                });
            }
        });

        createGroupButton.addEventListener('click', function() {
            const selectedUsers = document.getElementById("selected-users-list");
            const nameInput = document.getElementById("group-name-input");
            let name;
            let users = []
            selectedUsers.childNodes.forEach(child => users.push(child.firstElementChild.textContent));

            if(nameInput.value === "") {
                name = "Group Chat";
            } else {
                name = nameInput.value;
            }

            if(users.length > 0) {
                $.ajax({
                    type: "POST",
                    url: "{% url 'base:create_chat' %}",
                    data: {
                        "users": users,
                        "name": name,
                    },
                    dataType: "json",
                    success: function (data) {
                        const activeChat = document.querySelector('.chat-list li.active');
                        const chatList = document.getElementById('chat-list');
                        const chatElement = getChatElement(data["chat_id"], users);

                        if (activeChat) {
                            activeChat.classList.remove("active");
                        }
                        const noChatsBanner = document.querySelector("#no-chats-banner");
                        if (noChatsBanner) {
                            noChatsBanner.remove();
                        }

                        chatElement.firstElementChild.textContent = name;
                        chatList.insertBefore(chatElement, chatList.firstElementChild);
                        const chat_id = data["chat_id"];

                        chatElement.setAttribute("chat-id", chat_id);
                        chatElement.setAttribute("group", "true");
                        chatElement.removeAttribute("new");
                        chatUsers[chat_id] = users;

                        const notificationElement = document.querySelector(`.chat-list li[chat-id='${chat_id}'] .chat-notification`)
                        notificationElement.setAttribute("chat-id", chat_id);
                        newGroupOverlay.style.display = "none";
                        newGroupButton.classList.remove("active");
                        createChatSocket(chat_id);

                        allMessages[chat_id] = [];

                        chatElement.click();

                        sendGroupCreationMessages(chat_id, name);
                    },
                });
            }
        })

        function sendGroupCreationMessages(chat_id, name) {
            let users = chatUsers[chat_id];
            let isAnybodyOnline = false;

            for (let user in users) {
                waitForSocketConnection(userSockets[users[user]], function() {
                    if (isUserOnline[users[user]]) {
                        isAnybodyOnline = true;
                        userSockets[users[user]].send(JSON.stringify({
                            'chat_id': chat_id,
                            'name': name,
                            'type': 'group_creation',
                            'source_username': '{{ request.user.username }}',
                        }));
                    }
                });
            }
            return isAnybodyOnline;
        }

        //searching users with pressing enter
        document.getElementById('search-user-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('search-user-button').click();
            }
        });

        document.getElementById('new-group-search-user-input').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                document.getElementById('new-group-search-user-button').click();
            }
        })

        newChatButton.addEventListener('click', function() {
            if (newChatOverlay.style.display === "none") {
                newChatOverlay.style.display = "block";
                newGroupOverlay.style.display = "none";
                newGroupButton.classList.remove("active");
                this.classList.add("active");
                let input = document.getElementById("search-user-input");
                input.focus();
            } else {
                newChatOverlay.style.display = "none";
                this.classList.remove('active');
            }
        })

        newGroupButton.addEventListener('click', function() {
            if (newGroupOverlay.style.display === "none") {
                newGroupOverlay.style.display = "block";
                newChatOverlay.style.display = "none";
                newChatButton.classList.remove("active");
                this.classList.add("active");
                let input = document.getElementById("new-group-search-user-input");
                input.focus();
            } else {
                newGroupOverlay.style.display = "none";
                this.classList.remove('active');
            }
        })

        document.getElementById('logout-button').addEventListener('click', function() {
            sessionStorage.clear();
            let form = document.getElementById('logout-form');
            form.submit();
        })

        goBottomButton.addEventListener('click', function() {
            chatMessages.scrollTo(0, chatMessages.scrollHeight);

            goBottomButton.style.display = "none";
        })

        emojiPickerButton.addEventListener('click', function() {
            if (!emojiPickerButton.hasAttribute("disabled")) {
                if (emojiPicker.style.display === "none") {
                    emojiPickerButton.classList.add("active");
                    emojiPicker.style.display = "block";
                } else {
                    emojiPickerButton.classList.remove("active");
                    emojiPicker.style.display = "none";
                    messageInput.focus();
                }
            }
        })

        attachmentButton.addEventListener('click', function(){
            fileInput.click();
        })

        fileInput.addEventListener('change', function(){
            const activeChat = document.querySelector('.chat-list li.active');
            let activeChatId = activeChat.getAttribute('chat-id');
            const file = fileInput.files[0];

            if (file && file.size <= {{ DATA_UPLOAD_MAX_MEMORY_SIZE }}) {
                let fr = new FileReader();
                fr.onloadend = function() {
                    (async () => {
                        let publicKeysArmored = [userPublicKey];
                        for (let i = 0; i < chatUsers[activeChatId].length; i++) {
                            publicKeysArmored.push(publicKeys[chatUsers[activeChatId][i]]);
                        }
                        const messageKeys = await Promise.all(publicKeysArmored.map(key => openpgp.readKey({armoredKey: key})));
                        const encrypted = await openpgp.encrypt({
                            message: await openpgp.createMessage({text: fr.result}),
                            encryptionKeys: messageKeys,
                        });
                        sendMessage(chatSockets[activeChatId], "chat_file", "{{ request.user.username }}", encrypted, file.name);

                        //let xhr = new XMLHttpRequest();

                        //xhr.open("POST", '{% url 'base:upload' %}', true);
                        //xhr.setRequestHeader("X-CSRFToken", getCookie('csrftoken'));
                        //xhr.setRequestHeader("chat", activeChatId);
                        //xhr.setRequestHeader("name", file.name);
                        //xhr.send(file);

                        //xhr.onreadystatechange = function () {
                            //if (xhr.readyState === 4) {
                                //message = JSON.parse(xhr.responseText)
                                //sendMessage(chatSockets[activeChatId], "chat_file", "{{ request.user.username }}", message["message"], message["fileName"]);
                            //}
                        //}
                    })();
                }
                fr.readAsDataURL(file)
            } else {
                alert("File size should be less than 20 MBs.");
            }
        })

        callButton.addEventListener('click', async function () {
            const activeChat = document.querySelector('.chat-list li.active');

            if (!inCall) {
                voiceCall = new RTCPeerConnection();

                await localStreamToRtc();
                await voiceCall.createOffer({offerToReceiveAudio: true}).then(o => voiceCall.setLocalDescription(o));
                voiceCallChatId = activeChat.getAttribute("chat-id");

                voiceCall.ontrack = handleTrackEvent;
                voiceCall.onicecandidate = handleICECandidateEvent;

                sendMessage(chatSockets[activeChat.getAttribute("chat-id")], "call_request", "{{ request.user.username }}", voiceCall.localDescription);
            }
        })

        function handleSendChannelStatusChange() {

        }

        function beep() {
            let snd = new Audio("{% static 'base/telephone-ring.wav' %}")
            snd.currentTime = 0;
            snd.autoplay = true;
            snd.play();
        }

        async function localStreamToRtc() {
            await navigator.mediaDevices
                .getUserMedia({video: false, audio: {
                autoGainControl: false,
                channelCount: 2,
                echoCancellation: false,
                latency: 0,
                noiseSuppression: false,
                sampleRate: 48000,
                sampleSize: 16,
                volume: 1.0
              }})
                .then((stream) => {
                    localStream = stream;
                })
                .catch((err) => {
                    console.error(`you got an error: ${err}`);
                });

            try {
                localStream.getTracks().forEach(track => voiceCall.addTrack(track, localStream)
                );
            } catch (err) {
                console.error(`you got an error: ${err}`);
            }
        }

        function handleTrackEvent(event) {
          console.log(event);
        }

        function handleICECandidateEvent(event) {
          if (event.candidate) {
            sendMessage(chatSockets[voiceCallChatId], "new_ice_candidate", "{{ request.user.username }}", event.candidate);
          }
        }

        emojiPicker.addEventListener('emoji-click', event => messageInput.value = messageInput.value + event["detail"]["unicode"]);
    </script>
</body>
